// Generated by CoffeeScript 1.12.1
(function() {
  var ColinearityEquation, matrix, rotateMatrix, vector;

  switch (false) {
    case !require:
      vector = require('vector');
      matrix = require('matrix');
      rotateMatrix = require('rotateMatrix');
      break;
    case !window:
      vector = window.vector;
      matrix = window.matrix;
      rotateMatrix = rotateMatrix;
  }

  ColinearityEquation = (function() {
    var decentricLensDistortion, radialLensDistortion;

    function ColinearityEquation(parameter, interiorOrientalParameter) {
      var c, k, kappa, omega, p, phi, xo, xp, yo, yp, zo;
      c = parameter.c, xp = parameter.xp, yp = parameter.yp, omega = parameter.omega, phi = parameter.phi, kappa = parameter.kappa, xo = parameter.xo, yo = parameter.yo, zo = parameter.zo, k = parameter.k, p = parameter.p;
      this.groundToPhotoMatrix = rotateMatrix.wfk(omega, phi, kappa);
      this.photoToGroundMatrix = this.groundToPhotoMatrix.transpose();
      this.cameraInSpaceVector = vector.createFromArray([xo, yo, zo]);
      this.cameraToPhotoVector = interiorOrientalParameter || vector.createFromArray([xp, yp, c]);
      this.k = k;
      this.p = p;
    }

    radialLensDistortion = function(point, k) {
      return k.reduce(function(distortion, ki, i) {
        var powern;
        powern = (i + 1) * 2 + 1;
        return distortion.add(point.power(powern).multiply(ki));
      }, vector.createFromNumber(0));
    };

    decentricLensDistortion = function(point, p) {
      var p1, p2, proc, r, x, y;
      x = point[0];
      y = point[1];
      r = point.norm();
      p1 = p[0], p2 = p[1];
      proc = function(p1, p2, x, y, r) {
        return p1 * (Math.pow(r, 2) + 2 * Math.pow(x, 2)) + 2 * p2 * x * y;
      };
      return vector.createFromArray([proc(p1, p2, x, y, r), proc(p2, p1, y, x, r), 0]);
    };

    ColinearityEquation.prototype.groundToPhoto = function(groundPointVector) {
      var lensAxisToPoint, photoPoint, scale, unScaleVector;
      if (!(groundPointVector instanceof vector.create)) {
        groundPointVector = vector.createFromArray(groundPointVector);
      }
      unScaleVector = this.groundToPhotoMatrix.multiply(groundPointVector.minus(this.cameraInSpaceVector));
      scale = -this.cameraToPhotoVector[2] / unScaleVector[2];
      photoPoint = unScaleVector.multiply(scale).add(this.cameraToPhotoVector);
      lensAxisToPoint = photoPoint.minus(this.cameraToPhotoVector);
      lensAxisToPoint[2] = 0;
      console.log(radialLensDistortion(lensAxisToPoint, this.k));
      console.log(decentricLensDistortion(lensAxisToPoint, this.p));
      return photoPoint.minus(radialLensDistortion(lensAxisToPoint, this.k)).minus(decentricLensDistortion(lensAxisToPoint, this.p));
    };

    ColinearityEquation.prototype.photoToGround = function(photoPoint, groundPointVector) {
      var cameraToPointInGroundVector, photoPointVector, scale, unScaleVector;
      if (groundPointVector == null) {
        groundPointVector = vector.createFromArray([0/0, 0/0, 0]);
      }
      photoPointVector = photoPoint instanceof vector.create ? photoPoint : vector.createFromArray(photoPoint);
      unScaleVector = this.photoToGroundMatrix.multiply(photoPointVector.minus(this.cameraToPhotoVector).multiply(-1));
      cameraToPointInGroundVector = groundPointVector.minus(this.cameraInSpaceVector);
      scale = unScaleVector.reduce(function(s, x, i, m) {
        if (s) {
          return s;
        } else {
          return x / cameraToPointInGroundVector[i];
        }
      }, 0/0);
      return unScaleVector.multiply(1 / scale).add(this.cameraInSpaceVector);
    };

    return ColinearityEquation;

  })();

  switch (false) {
    case !(module && module.exports):
      module.exports = ColinearityEquation;
      break;
    case !exports:
      exports.colinearitySolverGenerator = ColinearityEquation;
      break;
    case !window:
      window.colinearitySolverGenerator = ColinearityEquation;
  }

}).call(this);
