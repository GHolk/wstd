
switch
# load matrix and vector module
    when require
        vector = require 'vector'
        matrix = require 'matrix'
        rotateMatrix = require 'rotateMatrix'
    when window
        vector = window.vector
        matrix = window.matrix
        rotateMatrix = rotateMatrix


class ColinearityEquation
    constructor: (parameter, interiorOrientalParameter) ->
        # [xa - xp] = scale * M * [Xp - Xo]

        {c,xp,yp, omega,phi,kappa, xo,yo,zo, k,p} = parameter

        # compute rotate matrix from ground to image. 
        # spaceToPhotoMatrix = M
        @groundToPhotoMatrix = rotateMatrix.wfk omega, phi, kappa
        @photoToGroundMatrix = @groundToPhotoMatrix.transpose()

        # camera position vector in ground system.
        # cameraVector = Xo
        @cameraInSpaceVector = vector.createFromArray [xo,yo,zo]

        @cameraToPhotoVector =
            interiorOrientalParameter || vector.createFromArray [xp,yp,c]

        @k = k
        @p = p

    # function find photo xy by ground xyz
    # @param {number} ground x
    # @param {number} ground y
    # @param {number} ground z
    # @return {vector} [x,y,z] in vector object, 
    #   vector is a array like object defined in vector module.
    radialLensDistortion = (point,k) ->
        k.reduce(
            (distortion, ki, i) ->
                powern = (i+1) * 2 + 1
                distortion.add point.power(powern).multiply ki
            vector.createFromNumber 0
        )

    decentricLensDistortion = (point,p) ->
        x = point[0]
        y = point[1]
        r = point.norm()
        [p1,p2] = p
        proc = (p1,p2,x,y,r) -> p1*(r**2 + 2 * x**2) + 2*p2*x*y
        vector.createFromArray [
            proc p1,p2,x,y,r
            proc p2,p1,y,x,r
            0
        ]

    groundToPhoto: (groundPointVector) ->
        if ! (groundPointVector instanceof vector.create)
            groundPointVector = vector.createFromArray groundPointVector

        unScaleVector = @groundToPhotoMatrix
            .multiply groundPointVector.minus @cameraInSpaceVector

        scale = - @cameraToPhotoVector[2] / unScaleVector[2]

        photoPoint = unScaleVector
            .multiply scale
            .add @cameraToPhotoVector

        lensAxisToPoint = photoPoint.minus @cameraToPhotoVector
        lensAxisToPoint[2] = 0

        photoPoint
            .minus radialLensDistortion lensAxisToPoint,@k
            .minus decentricLensDistortion lensAxisToPoint,@p

    photoToGround: (
        photoPoint
        groundPointVector = vector.createFromArray [NaN, NaN, 0]
    ) ->
        photoPointVector = if photoPoint instanceof vector.create
        then photoPoint
        else vector.createFromArray photoPoint

        unScaleVector = @photoToGroundMatrix.multiply(
            photoPointVector
                .minus @cameraToPhotoVector
                .multiply -1
        )

        cameraToPointInGroundVector =
            groundPointVector.minus @cameraInSpaceVector

        scale = unScaleVector.reduce(
            (s,x,i,m) ->
                if s
                then s
                else x / cameraToPointInGroundVector[i]
            NaN
        )

        return unScaleVector
            .multiply 1/scale
            .add @cameraInSpaceVector


# export modules
switch
    when module && module.exports
        module.exports = ColinearityEquation
    when exports
        exports.colinearitySolverGenerator = ColinearityEquation
    when window
        window.colinearitySolverGenerator = ColinearityEquation

