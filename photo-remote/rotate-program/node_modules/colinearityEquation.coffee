
switch
# load matrix and vector module
    when require
        vector = require 'vector'
        matrix = require 'matrix'
        rotateMatrix = require 'rotateMatrix'
    when window
        vector = window.vector
        matrix = window.matrix
        rotateMatrix = rotateMatrix


class ColinearityEquation
    constructor: (parameter, interiorOrientalParameter) ->
        # [xa - xp] = scale * M * [Xp - Xo]

        {c,xp,yp, omega,phi,kappa, xo,yo,zo} = parameter

        # compute rotate matrix from ground to image. 
        # spaceToPhotoMatrix = M
        @groundToPhotoMatrix = rotateMatrix.wfk omega, phi, kappa
        @photoToGroundMatrix = @groundToPhotoMatrix.transpose()

        # camera position vector in ground system.
        # cameraVector = Xo
        @cameraInSpaceVector = vector.createFromArray [xo,yo,zo]

        @cameraToPhotoVector =
            interiorOrientalParameter || vector.createFromArray [xp,yp,c]


    # function find photo xy by ground xyz
    # @param {number} ground x
    # @param {number} ground y
    # @param {number} ground z
    # @return {vector} [x,y,z] in vector object, 
    #   vector is a array like object defined in vector module.
    groundToPhoto: (groundPointVector) ->
        if ! groundPointVector instanceof vector.create
            groundPointVector = vector.createFromArray groundPointVector

        unScaleVector = @groundToPhotoMatrix
            .multiply groundPointVector.minus @cameraInSpaceVector

        # solve the scala factor by focus
        scale = - @cameraToPhotoVector[2] / unScaleVector[2]

        # scale unScaleVector
        unScaleVector
            .multiply scale
            .add @cameraToPhotoVector

    photoToGround: (
        photoPoint
        groundPointVector = vector.createFromArray [NaN, NaN, 0]
    ) ->
        photoPointVector = if photoPoint instanceof vector.create
        then photoPoint
        else vector.createFromArray photoPoint

        unScaleVector = @photoToGroundMatrix.multiply(
            photoPointVector
                .minus @cameraToPhotoVector
                .multiply -1
        )

        cameraToPointInGroundVector =
            groundPointVector.minus @cameraInSpaceVector

        scale = unScaleVector.reduce(
            (s,x,i,m) ->
                if s
                then s
                else x / cameraToPointInGroundVector[i]
            NaN
        )

        return unScaleVector
            .multiply 1/scale
            .add @cameraInSpaceVector


# export modules
switch
    when module && module.exports
        module.exports = ColinearityEquation
    when exports
        exports.colinearitySolverGenerator = ColinearityEquation
    when window
        window.colinearitySolverGenerator = ColinearityEquation

