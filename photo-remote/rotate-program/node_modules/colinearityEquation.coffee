
switch
# load matrix and vector module
    when require
        vector = require 'vector'
        matrix = require 'matrix'
        rotateMatrix = require 'rotateMatrix'
    when window
        vector = window.vector
        matrix = window.matrix
        rotateMatrix = rotateMatrix


class ColinearityEquation
    constructor: (parameter, interiorOrientalParameter) ->

        {c,xp,yp, omega,phi,kappa, xo,yo,zo, k,p} = parameter

        @groundToPhotoMatrix = rotateMatrix.wfk omega, phi, kappa
        @photoToGroundMatrix = @groundToPhotoMatrix.transpose()

        @cameraInSpaceVector = vector.createFromArray [xo,yo,zo]

        @cameraToPhotoVector =
            interiorOrientalParameter || vector.createFromArray [xp,yp,c]

        @k = k || interiorOrientalParameter.k
        @p = p || interiorOrientalParameter.p

    # 由點相對光軸座標與輻射畸變參數 K ，計算輻射畸變。
    # dr = k1*r^3 + k2*r^5 + ...
    #
    # @parm {vector} point: 相對於光軸的點座標 r 。
    # @parm {array} k: 輻射畸變參數組成的陣列 [k1,k2,k3, ... ] 。
    # @return {vector} : 輻射畸變的量，一個向量， [dx,dy,0] 。
    radialLensDistortion = (point,k) ->
        k.reduce(
            (distortion, ki, i) ->
                # 次方數 = n*2 + 1 ，但陣列從 0 開始。
                powern = (i+1) * 2 + 1
                # 輻射畸變 += r^n * ki
                distortion.add point.power(powern).multiply ki
            vector.createFromNumber 0
        )

    # 由點相對光軸的座標計算偏心畸變的量。
    # 找不到向量公式，只好一項項算。
    #
    # @parm {vector} point: 相對於光軸的點座標 r 。
    # @parm {array} p: 由 p1,p2 組成的陣列。
    # @return {vector} : 偏心畸變的量，一個向量， [dx,dy,0] 。
    decentricLensDistortion = (point,p) ->
        x = point[0]
        y = point[1]
        r = point.norm()  # r = 向量長度
        [p1,p2] = p
        # 偏心畸變的公式， x y 的 p1 p2 是顛倒的。
        proc = (p1,p2,x,y,r) -> p1*(r**2 + 2 * x**2) + 2*p2*x*y
        # 返回一個向量
        vector.createFromArray [
            proc p1,p2,x,y,r
            proc p2,p1,y,x,r
            0
        ]

    # 將地面點 X Y Z 轉到像空間 x y ，計算上用向量計算。
    # @param {vector} : 地面點座標
    # @return {vector} : 像空間座標
    #
    # [x y z] = s * M(omega,phi,kappa) * [X Y Z]
    # 其中 X Y Z M z 已知， s = z / M * [X Y Z] ，
    # 知道 s 即可解得 x y 。
    groundToPhoto: (groundPointVector) ->
        if ! (groundPointVector instanceof vector.create)
            groundPointVector = vector.createFromArray groundPointVector

        # 計算 M * [X Y Z] ， [X Y Z] 為相對相機，
        # 所以要先減掉相機座標。
        unScaleVector = @groundToPhotoMatrix
            .multiply groundPointVector.minus @cameraInSpaceVector

        # 解 s = z / (M * [X Y Z])(3) ，
        # js 陣列從 0 開始。
        scale = - @cameraToPhotoVector[2] / unScaleVector[2]

        # 解得 s ，即可算 [x y z] 。
        photoPoint = unScaleVector
            .multiply scale
            .add @cameraToPhotoVector

        # 計算光軸到點的向量，修正透鏡畸變用。
        lensAxisToPoint = photoPoint.minus @cameraToPhotoVector
        lensAxisToPoint[2] = 0

        # 修正透鏡畸變
        photoPoint
            .minus radialLensDistortion lensAxisToPoint,@k
            .minus decentricLensDistortion lensAxisToPoint,@p

    photoToGround: (
        photoPoint
        groundPointVector = vector.createFromArray [NaN, NaN, 0]
    ) ->
        photoPointVector = if photoPoint instanceof vector.create
        then photoPoint
        else vector.createFromArray photoPoint

        unScaleVector = @photoToGroundMatrix.multiply(
            photoPointVector
                .minus @cameraToPhotoVector
                .multiply -1
        )

        cameraToPointInGroundVector =
            groundPointVector.minus @cameraInSpaceVector

        scale = unScaleVector.reduce(
            (s,x,i,m) ->
                if s
                then s
                else x / cameraToPointInGroundVector[i]
            NaN
        )

        return unScaleVector
            .multiply 1/scale
            .add @cameraInSpaceVector


# export modules
switch
    when module && module.exports
        module.exports = ColinearityEquation
    when exports
        exports.colinearitySolverGenerator = ColinearityEquation
    when window
        window.colinearitySolverGenerator = ColinearityEquation

