
vector = require 'vector'

matrix = (vector.create() for i in [1..3])
# Matrix3 is 2 demition array,
# access m(i,j) by m[i][j].

matrix.size = [3,3] # Matrix3 is [3,3] matrix.

matrix.create = ->
# this need be bind to origin matrix object.
# bind by closure better than by `.bind()`
    newMatrix = Object.create this
    newMatrix.forEach (x,i,m) ->
        if i[1] == 0 then m[i[0]] = vector.create()
    return newMatrix

matrix.forEach = (callback) ->
# callback will get 3 argument v,i,m, 
# v = current value, i = [row, col], m = matrix it self.
# row first order.
    for y in [0 ... @size[0]]
        for x in [0 ... @size[1]]
            callback @[y][x], [y,x], this
    return undefined

matrix.map = (callback) ->
# map will return a new Matrix3 instance.
    m = matrix.create()
    @forEach (v,i,a) -> m[i[0]][i[1]] = callback v,i,a
    return m

matrix.reduce = (callback, sum) ->
    @forEach (v,i,a) -> sum = callback sum, v, i, a
    return sum

matrix[':'] = (n) ->
# m[':'](n) to access nth column of m, 
# just like syntax of matlab. 
    @reduce(
        (s,v,i) ->
            s[i[0]] = v if i[1] == n
            return s
        vector.create()
    )

matrix.multiply = (target) ->
# do matrix multiply or vector multiply.
    if typeof target == 'number'
        @multiplyScalar target
    else if target.size && target.size.length == 2
        @multiplyMatrix target
    else if target instanceof Array
        @multiplyVector target
    else
        throw new Error "not vector or matrix"

matrix.multiplyMatrix = (m) ->
# matrix to matrix multiply, return a new matrix.
    @map (v,i,a) ->
        a[i[0]].dot m[':'](i[1])

matrix.multiplyVector = (v) ->
# vector is 1 demetion array.
# matrix to vector multiply, return a new vector.
    v.map (vi,i,v) => this[i].dot v

matrix.multiplyScalar = (scalar) ->
    @map (x) -> scalar * x

matrix.add = (m) ->
# add by matrix, return a new matrix.
    @map (v,i) -> v + m[i[0]][i[1]]

matrix.minus = (m) ->
    @add m.multiply -1

matrix.slice = (start, end) ->
# convert Matrix3 into 1 demantion array, and slice it.
    this.reduce(
        (s,v) ->
            s.push v
            return s
        []
    ).slice start, end

matrix.toString = ->
    @join()

matrix.join = (fs = '\t', rs = '\n') ->
    @reduce(
        (s,x,i) ->
            switch
                when i[0] == 0 && i[1] == 0
                    s + x
                when i[1] == 0
                    s + rs + x
                else
                    s + fs + x
        ''
    )

matrix.createFromNumber = (x) ->
    @map -> x

matrix.createIdentity = ->
    @map (x,i) -> if i[0] == i[1] then 1 else 0

matrix.createFromArray = (a) ->
    @map (x,i) -> a[ i[0]*3 + i[1] ]

matrix.createFromArray2D = (a) ->
    @map (x,i) -> a[ i[0] ][ i[1] ]

matrix.every = (callback) ->
    @reduce(
        (t,x,i,m) -> t && callback x,i,m
        true
    )

matrix.some = (callback) ->
    @reduce(
        (t,x,i,m) -> t || callback x,i,m
        false
    )

matrix.equal = (m, error = 1e-5) ->
    @multiply(-1).add(m).every (x) -> Math.abs(x) <= error

matrix.det = ->
    mod = (s) -> ((s % 3) + 3) % 3

    right = @reduce(
        (a,x,i) ->
            j = mod i[1] - i[0]
            a[j] *= x
            return a
        [1,1,1]
    ).reduce ((s,x) -> s+x), 0

    left = @reduce(
        (a,x,i) ->
            j = mod i[1] + i[0]
            a[j] *= x
            return a
        [1,1,1]
    ).reduce ((s,x) -> s+x), 0

    return right - left

matrix.constructor = matrix.create
matrix.create.prototype = matrix

if module && module.exports
    module.exports = matrix
else if window
    window.matrix = matrix

