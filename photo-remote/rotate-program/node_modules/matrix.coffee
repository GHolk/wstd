
matrix =
# Matrix3 is 2 demition array,
# access m(i,j) by m[i][j].

    '0': []
    '1': []
    '2': []
    size: [3,3] # Matrix3 is [3,3] matrix.

    forEach: (callback) ->
    # callback will get 3 argument v,i,m, 
    # v = current value, i = [row, col], m = matrix it self.
    # row first order.
        for i in [0 ... @size[0]]
            for j in [0 ... @size[1]]
                callback this[i][j], [i,j], this
        return undefined

    map: (callback) ->
    # map will return a new Matrix3 instance.
        m = @create()
        @forEach (v,i,a) -> m[i[0]][i[1]] = callback v,i,a
        return m

    reduce: (callback, sum) ->
        @forEach (v,i,a) -> sum = callback sum, v, i, a
        return sum

    ':': (n) ->
    # m[':'](n) to access nth column of m, 
    # just like syntax of matlab. 
        @reduce(
            (s,v,i) ->
                s.push v if i[1] == n
                return s
            []
        )

    multiply: (target) ->
    # do matrix multiply or vector multiply.
        if typeof target == 'number'
            @multiplyScalar target
        else if target.size.length == 2
            @multiplyMatrix target
        else if target.size.length == 1
            @multiplyVector target
        else
            throw new Error "not vector or matrix"

    multiplyMatrix: (m) ->
    # matrix to matrix multiply, return a new matrix.
        @map (v,i,a) ->
            a[i[0]].reduce(
                (s,v,j) -> s + v*m[j][i[1]]
                0
            )

    multiplyVector: (v) ->
    # vector is 1 demetion array.
    # matrix to vector multiply, return a new vector.
        v.map (vi,i,v) =>
            this[i].reduce(
                (s,mi,i) -> s + mi*v[i]
                0
            )

    multiplyScalar: (scalar) ->
        @map (x) -> scalar * x

    add: (m) ->
    # add by matrix, return a new matrix.
        @map (v,i) -> v + m[i[0]][i[1]]

    slice: (start, end) ->
    # convert Matrix3 into 1 demantion array, and slice it.
        (this.reduce ((s,v) -> s.push v), []).slice start, end

    toString: ->
        @reduce(
            (s,v,i) ->
                if i[1] == 0
                then s + '\n' + v
                else s + '\t' + v
            ''
        )

    createFromNumber: (x) ->
        @map -> x

    createIdentity: ->
        @map (x,i) -> if i[0] == i[1] then 1 else 0

    createFromArray: (a) ->
        @map (x,i) -> a[ i[0]*3 + i[1] ]

    createFromArray2D: (a) ->
        @map (x,i) -> a[ i[0] ][ i[1] ]

matrix.create = ->
# this need be bind to origin matrix object.
    newMatrix = Object.create matrix
    @forEach (x,i) ->
        newMatrix[i[0]] = [] if i[1] == 0
    return newMatrix

if module && module.exports
    module.exports = matrix
else if window
    window.matrix = matrix

