
switch
# load matrix and vector module
    when require
        vector = require 'vector'
        matrix = require 'matrix'
        rotateMatrix = require 'rotateMatrix'
    when window
        vector = window.vector
        matrix = window.matrix
        rotateMatrix = rotateMatrix

# function input exterior, interior oriental parameter,
# output a colinearity bottom-up solver.
#
# @param {object} parameter of all or only exterior parameter.
#   example: parameter = {  # exterior parameter object
#       # mm
#       xo: 80.3735
#       yo: 98.8612
#       zo: 634.6268
#
#       # radian
#       omega: 0.0699
#       phi: -0.1030
#       kappa: 2.8744
#
#       # optional, can input from second argument.
#       c: 3.984584
#       xp: 0.041933
#       yp: -0.016958
#   }
#   
# @param {array} optional interior oriental parameter array, 
#   in order of [xa, ya, c]. 
#   example: [3.984584, 0.041933, -0.016958]  # mm
#
#   if not defined interiorOrientalParameter,
#   will get xa,ya,c from parameter. 
#
# @return {function} a function transform ground x,y,z to photo x,y,z. 
#
colinearitySolverGenerator = (parameter, interiorOrientalParameter) ->
    # [xa - xp] = scale * M * [Xp - Xo]

    {c,xp,yp, omega,phi,kappa, xo,yo,zo} = parameter

    # compute rotate matrix from ground to image. 
    # spaceToPhotoMatrix = M
    spaceToPhotoMatrix = rotateMatrix.wfk omega, phi, kappa

    # camera position vector in ground system.
    # cameraVector = Xo
    cameraVector = vector.createFromArray [xo,yo,zo]

    # return a function base on previous 3 vector/matrix.
    # @param {number} ground x
    # @param {number} ground y
    # @param {number} ground z
    # @return {vector} [x,y,z] in vector object, 
    #   vector is a array like object defined in vector module.
    cameraToPhotoVector =
        interiorOrientalParameter || vector.createFromArray [xp,yp,c]


    # return a function base on previous 3 vector/matrix.
    return (xa,ya,za) ->
        # pointVector = Xp
        pointVector = vector.createFromArray [xa,ya,za]

        # unScaleVector = M * [Xp - Xo]
        unScaleVector = spaceToPhotoMatrix
            .multiply pointVector.add cameraVector.multiply -1

        # solve the scala factor by focus
        scale = -cameraToPhotoVector[2] / unScaleVector[2]

        # scale unScaleVector
        unScaleVector
            .multiply scale

            # add xp is answer
            .add cameraToPhotoVector

# export modules
switch
    when module && module.exports
        module.exports = colinearitySolverGenerator
    when exports
        exports.colinearitySolverGenerator = colinearitySolverGenerator
    when window
        window.colinearitySolverGenerator = colinearitySolverGenerator

