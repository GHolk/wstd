<!DOCTYPE HTML>
<html lang="zh-TW" prefix="og: http://ogp.me/ns#">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta name="author" property="og:article:author" content="c34031328">
<meta name="copyright" content="Common Creative, by c34031328">
<meta name="generator" content="vim, markdown">
<!-- 以上一般不用改，以下才要改。 -->

<!-- 後設資料 -->
<meta name="date" property="og:article:public_time" content="2017-04-14">
<meta name="keywords" property="og:article:tag" content="js,coffee-script,homework,program,computer">
<link rel="index" type="text/html" href="index.html" title="首頁">

<!-- 和網頁位置有關 -->
<link rel="stylesheet" type="text/css" href="../../ext/word.css">

<title>旋轉矩陣程式記錄</title>
</head>
<body>
<main>
<h1 id="旋轉矩陣計算">旋轉矩陣程式記錄</h1>
<p>三度空間中一個點，
分別繞 X Y Z 軸旋轉 &Omega; &Phi; &Kappa; 弧度，
結果可以表示成旋轉矩陣乘上該點的座標向量；
實作中需要用到矩陣的相乘，
將多次旋轉的相乘，用一個矩陣代表三次轉旋。</p>
<h2 id="低階的 C 語言">低階的 C 語言</h2>
<p>一開始用 C 寫，結果覺得宣告矩陣超麻煩。
我是用二維陣列模擬矩陣，
但 C 又只能在初始化陣列時對多個陣列賦值。
覺得不管怎麼作都很麻煩，
在副函數宣告的矩陣又不能回傳，
試了很多寫法都不滿意。</p>
<p>C 的問題是對底層過於嚴格，
我認為需要親自管理記憶體的語言都太低階，
不想用。</p>
<h2 id="JS 物向導向">JS 物向導向</h2>
<p>後來改用我唯一熟練的語言 JavaScript 寫，
就她不尋常的 <strong>物件導向</strong> 風格來寫。
宣告一個 matrix class ，
有 public 方法 multiply ，
可以接受另一個 matrix 作輸入，
返回一個新的 matrix ；
所以可以像 jQuery <strong>鏈式呼叫</strong> ：
<code>m4 = m1.multiply(m2).multiply(m3)</code> 。</p>
<p>用 matlab 寫，還可以用匿名函數，
一行搞定一種矩陣宣告。
<code>mw = @(w) [1 0 0; 0 cos(w) sin(w); 0 -sin(w) cos(w)]</code>
可惜老師規定不能用 matlab QQ</p>
<p>其實我是用 JS 的方言 CoffeeScript 寫的，
然後再編譯成 JS ，
最原始是 <a href="wfk.coffee">wfk.coffee</a> ，
編譯好的 JS 是 <a href="wfk.js">wfk.js</a> 。</p>
<p>可以直接引用原始碼，
看要用 nodejs require
或直接在網頁中引用。
或用我包好的版本： <a href="wfk.html">計算旋轉矩陣</a> 。
（媽的超麻煩，寫這個浪費了我
寫核心程式 2 到 3 倍的時間。）</p>

<pre><code>class Matrix3
    constructor: (a = 0) -&gt;
        a = [1..9].map( -&gt; a ) if typeof a == &#39;number&#39;

        if a.length &gt;= 9
            for i in [0..2]
                this[i] = a.slice i*3,(i+1)*3
        else if a.length &gt;= 3
            for i in [0..2]
                this[i] = a[i].slice 0
        else
            throw new Error &#39;arguments not array!&#39;

    &#39;:&#39;: (n) -&gt; this.reduce(
        (s,v,i) -&gt;
            s.push v if i[1] == n
            return s
        []
    )
    size: [3,3]
    forEach: (callback) -&gt;
        for i in [0..2]
            for j in [0..2]
                callback this[i][j], [i,j], this
        return undefined

    map: (callback) -&gt;
        m = new Matrix3()
        this.forEach (v,i,a) -&gt; m[i[0]][i[1]] = callback v,i,a
        return m

    reduce: (callback, sum) -&gt;
        this.forEach (v,i,a) -&gt; sum = callback sum, v, i, a
        return sum

    multiply: (m) -&gt;
        @map (v,i,a) -&gt;
            a[i[0]].reduce(
                (s,v,j) -&gt; s + v*m[j][i[1]]
                0
            )

    add: (m) -&gt; @map (v,i) -&gt; v + m[i[0]][i[1]]

    slice: (start, end) -&gt;
        (this.reduce ((s,v) -&gt; s.push v), []).slice start, end


sin = Math.sin
cos = Math.cos

rotateMatrix =
    omega: (w) -&gt; new Matrix3 [
        [1, 0, 0]
        [0, cos(w), sin(w)]
        [0, -sin(w), cos(w)]
    ]
    phi: (f) -&gt; new Matrix3 [
        [cos(f), 0, -sin(f)]
        [0, 1, 0]
        [sin(f), 0, cos(f)]
    ]
    kappa: (k) -&gt; new Matrix3 [
        [cos(k), sin(k), 0]
        [-sin(k), cos(k), 0]
        [0, 0, 1]
    ]

rotateWFKMatrix = (w, f, k) -&gt;
    rotateMatrix.kappa k
        .multiply rotateMatrix.phi f
        .multiply rotateMatrix.omega w

if  typeof exports == &#39;object&#39;
    md = exports
else if typeof window == &#39;object&#39;
    window.rotateWFK = {}
    md = window.rotateWFK
else
    md = {}

md.Matrix3 = Matrix3
md.rotateMatrix = rotateMatrix
md.rotateWFKMatrix = rotateWFKMatrix
</code></pre>
</main>

<pre class="markdown raw">
旋轉矩陣程式記錄
================
三度空間中一個點，
分別繞 X Y Z 軸旋轉 &Omega; &Phi; &Kappa; 弧度，
結果可以表示成旋轉矩陣乘上該點的座標向量；
實作中需要用到矩陣的相乘，
將多次旋轉的相乘，用一個矩陣代表三次轉旋。

低階的 C 語言
-------------
一開始用 C 寫，結果覺得宣告矩陣超麻煩。
我是用二維陣列模擬矩陣，
但 C 又只能在初始化陣列時對多個陣列賦值。
覺得不管怎麼作都很麻煩，
在副函數宣告的矩陣又不能回傳，
試了很多寫法都不滿意。

C 的問題是對底層過於嚴格，
我認為需要親自管理記憶體的語言都太低階，
不想用。

JS 物向導向
-----------
後來改用我唯一熟練的語言 JavaScript 寫，
就她不尋常的 **物件導向** 風格來寫。
宣告一個 matrix class ，
有 public 方法 multiply ，
可以接受另一個 matrix 作輸入，
返回一個新的 matrix ；
所以可以像 jQuery **鏈式呼叫** ：
`m4 = m1.multiply(m2).multiply(m3)` 。

用 matlab 寫，還可以用匿名函數，
一行搞定一種矩陣宣告。
`mw = @(w) [1 0 0; 0 cos(w) sin(w); 0 -sin(w) cos(w)]`
可惜老師規定不能用 matlab QQ

其實我是用 JS 的方言 CoffeeScript 寫的，
然後再編譯成 JS ，
最原始是 [wfk.coffee](wfk.coffee) ，
編譯好的 JS 是 [wfk.js](wfk.js) 。

原始碼
------

可以直接引用原始碼，
看要用 nodejs `require`
或直接在網頁中引用。
或用我包好的版本： [計算旋轉矩陣](wfk.html) 。
（媽的超麻煩，寫這個浪費了我
寫核心程式 2 到 3 倍的時間。）

    class Matrix3
        constructor: (a = 0) ->
            a = [1..9].map( -> a ) if typeof a == 'number'
    
            if a.length >= 9
                for i in [0..2]
                    this[i] = a.slice i*3,(i+1)*3
            else if a.length >= 3
                for i in [0..2]
                    this[i] = a[i].slice 0
            else
                throw new Error 'arguments not array!'
    
        ':': (n) -> this.reduce(
            (s,v,i) ->
                s.push v if i[1] == n
                return s
            []
        )
        size: [3,3]
        forEach: (callback) ->
            for i in [0..2]
                for j in [0..2]
                    callback this[i][j], [i,j], this
            return undefined
    
        map: (callback) ->
            m = new Matrix3()
            this.forEach (v,i,a) -> m[i[0]][i[1]] = callback v,i,a
            return m
    
        reduce: (callback, sum) ->
            this.forEach (v,i,a) -> sum = callback sum, v, i, a
            return sum
    
        multiply: (m) ->
            @map (v,i,a) ->
                a[i[0]].reduce(
                    (s,v,j) -> s + v*m[j][i[1]]
                    0
                )
    
        add: (m) -> @map (v,i) -> v + m[i[0]][i[1]]
    
        slice: (start, end) ->
            (this.reduce ((s,v) -> s.push v), []).slice start, end
    
    
    sin = Math.sin
    cos = Math.cos
    
    rotateMatrix =
        omega: (w) -> new Matrix3 [
            [1, 0, 0]
            [0, cos(w), sin(w)]
            [0, -sin(w), cos(w)]
        ]
        phi: (f) -> new Matrix3 [
            [cos(f), 0, -sin(f)]
            [0, 1, 0]
            [sin(f), 0, cos(f)]
        ]
        kappa: (k) -> new Matrix3 [
            [cos(k), sin(k), 0]
            [-sin(k), cos(k), 0]
            [0, 0, 1]
        ]
    
    rotateWFKMatrix = (w, f, k) ->
        rotateMatrix.kappa k
            .multiply rotateMatrix.phi f
            .multiply rotateMatrix.omega w
    
    if  typeof exports == 'object'
        md = exports
    else if typeof window == 'object'
        window.rotateWFK = {}
        md = window.rotateWFK
    else
        md = {}
    
    md.Matrix3 = Matrix3
    md.rotateMatrix = rotateMatrix
    md.rotateWFKMatrix = rotateWFKMatrix

</pre>

<script src="../../ext/luser-meta.js" defer></script>

</body>
</html>
